// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/@prisma-app/client"
}


plugin hooks {
  provider = '@zenstackhq/tanstack-query'
  target = 'vue'
  output = 'lib/hooks' // This is a common output path, adjust if needed
}

// Enums

enum UserStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum CustomerType {
  RETAILER
  CA_RETAIL
  WHOLESALER
  CA_WHOLESALE
}

enum CustomerStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum ItemStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum OrderSystemStatus { // Renamed to avoid conflict with OrderItemStatus for clarity
  PENDING
  APPROVED
  ORDER_PROCESSING
  READY_TO_SHIP
  SHIPPED
  COMPLETED
  CANCELLED
  ARCHIVED
}

enum OrderItemProcessingStatus { // Renamed for clarity
  NOT_STARTED_PRODUCTION
  CUTTING
  SEWING
  FOAM_CUTTING
  STUFFING
  PACKAGING
  PRODUCT_FINISHED
  READY
}

enum OrderPriority {
  NO_PRIORITY
  LOW
  MEDIUM
  HIGH
}

enum ProductType {
  SPA_COVER
  COVER_FOR_COVER
}

enum SkirtType {
  CONN
  SLIT
}

enum TieDownPlacement {
  HANDLE_SIDE
  CORNER_SIDE
  FOLD_SIDE
}

// Models

model User {
  id                 String              @id @default(cuid())
  name               String
  email              String              @unique
  contactNumber      String?
  passwordHash       String? // Managed by Better-Auth, now optional
  emailVerified      Boolean?  // Managed by Better-Auth
  image              String?    // Added by Better-Auth
  status             UserStatus          @default(ACTIVE)
  hourlyRate         Decimal?            @db.Decimal(10, 2)
  organizationId     String? // For Better-Auth multi-tenancy if used

  // Fields for Better Auth Admin Plugin
  banned             Boolean?  // New
  banReason          String?   // New
  banExpires         DateTime? // New

  roles              UserRole[]
  itemProcessingLogs ItemProcessingLog[]
  auditLogs          AuditLog[]
  orderStatusLogs    OrderStatusLog[]
  itemStatusLogs     ItemStatusLog[]
  sessions           Session[]  // Added by Better-Auth
  accounts           Account[]  // Added by Better-Auth
  quickbooksToken    QuickbooksToken?
  barcodeScanners    BarcodeScanner[]

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  role               String?

  // Access Control Policies - HYBRID APPROACH
  
  // ROLE-BASED: Admin access for user management
  @@allow('create,read,update', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])

  // SELF-SERVICE: Users can read/update their own profile
  @@allow('read', auth() != null && id == auth().id)
  @@allow('update', auth() != null && id == auth().id) 

  // DELETE POLICIES with protection
  @@deny('delete', auth() != null && id == auth().id) // No self-deletion
  @@allow('delete', auth() != null && auth().roles?[role.name == "Super Admin"])
  @@deny('delete', auth() != null && auth().roles?[role.name == "Admin"] && roles?[role.name == "Super Admin"]) // Admins can't delete Super Admins
  @@allow('delete', auth() != null && auth().roles?[role.name == "Admin"])

  @@map("user")
}

model RoleType {
  id                 String   @id @default(cuid())
  name               String   @unique // e.g., "Office Employee", "Warehouse Staff", "Manager"
  description        String?
  color              String?   // For UI display (e.g., "#3B82F6")
  canUseStations     Boolean  @default(false) // Whether roles of this type can be assigned to stations
  isSystem           Boolean  @default(false) // System-defined types that can't be deleted
  displayOrder       Int      @default(0) // For UI ordering
  
  // Default permissions for this role type (JSON structure)
  defaultPermissions Json? // Structure: { "subjects": ["Order", "Item"], "actions": ["read", "update"] }

  roles              Role[]

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Access Control Policies - ROLE-BASED (Admin-only)
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
}

model Role {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?
  
  // Role Type association
  roleTypeId  String?
  roleType    RoleType?        @relation(fields: [roleTypeId], references: [id], onDelete: SetNull)

  users       UserRole[]
  permissions RolePermission[]
  stations    RoleStation[]

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Access Control Policies - ROLE-BASED (Admin-only)
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
}

model Permission {
  id          String           @id @default(cuid())
  action      String   // e.g., "create", "read", "update", "delete"
  subject     String   // e.g., "User", "Order", "CustomerItem"
  description String?
  roles       RolePermission[]

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([action, subject])

  // Access Control Policies - ROLE-BASED (Admin-only for security)
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
  @@allow('read', auth() != null && auth().roles?[role.name == "Admin"]) // Admins can view permissions
}

model UserRole {
  userId     String
  roleId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())
  assignedBy String? // Potentially a user ID or name

  @@id([userId, roleId])

  // Access Control Policies - ADMIN-ONLY (User role management)
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
  @@allow('read', auth() != null) // Anyone can see role assignments
}

model RolePermission {
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  assignedAt   DateTime   @default(now())

  @@id([roleId, permissionId])
  
  // Access Control Policies - ADMIN-ONLY (Permission management)
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
  @@allow('read', auth() != null && auth().roles?[role.name == "Admin"]) // Admins can view permission assignments
}

model Customer {
  id                   String         @id @default(cuid())
  quickbooksCustomerId String?        @unique // For QBO sync
  name                 String
  contactNumber        String?
  email                String?
  type                 CustomerType
  status               CustomerStatus @default(ACTIVE)
  shippingAddressLine1 String?
  shippingAddressLine2 String?
  shippingCity         String?
  shippingState        String?
  shippingZipCode      String?
  shippingCountry      String?
  billingAddressLine1  String?
  billingAddressLine2  String?
  billingCity          String?
  billingState         String?
  billingZipCode       String?
  billingCountry       String?

  orders               Order[]
  estimates            Estimate[]

  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt

  // Access Control Policies - ROLE-BASED (Business operations)
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
  @@allow('create,read,update', auth() != null && auth().roles?[role.name == "Customer Service"])
  @@allow('read', auth() != null && auth().roles?[role.name in ["Manager", "Warehouse Staff"]])
}

model Item {
  id                 String      @id @default(cuid())
  quickbooksItemId   String?     @unique
  name               String
  imageUrl           String?
  category           String?
  wholesalePrice     Decimal?    @db.Decimal(10, 2)
  retailPrice        Decimal?    @db.Decimal(10, 2)
  cost               Decimal?    @db.Decimal(10, 2)
  description        String?
  status             ItemStatus  @default(ACTIVE)
  isSpacoverProduct  Boolean     @default(false)
  productType        ProductType @default(SPA_COVER)
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  orderItems         OrderItem[]
  estimateItems      EstimateItem[]
  products           Product[]

  // Access Control Policies - ROLE-BASED (Product management)
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
  @@allow('create,read,update', auth() != null && auth().roles?[role.name in ["Manager", "Customer Service"]])
  @@allow('read', auth() != null && auth().roles?[role.name == "Warehouse Staff"])
}

model Product {
  id              String      @id @default(cuid())
  
  // Product specifications
  size            String   // e.g., "93X93"
  shape           String   // e.g., "Round", "Square", "Rectangular"
  pieces          Int      // e.g., 8
  foamThickness   String // e.g., "5\"-2.5\" STEAM STOPPER"
  skit            String   // e.g., "5-FL-SLIT", "Flap", "5 Connected"
  tiedown         String   // e.g., "6-TD", "4 Corner", "4-H"
  color           String   // e.g., "BLACK (VINYL)", "BLUE"
  
  // Pricing
  price           Decimal?    @db.Decimal(10, 2) // Price for this specific product configuration
  
  // Generated fields
  fullDescription String      @unique // Complete formatted description
  displayName     String         // Human-readable name
  
  // Relations
  orderItems      OrderItem[]
  item            Item?      @relation(fields: [itemId], references: [id])
  itemId          String?

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Access Control Policies
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
  @@allow('create,read,update', auth() != null && auth().roles?[role.name in ["Manager", "Customer Service"]])
  @@allow('read', auth() != null && auth().roles?[role.name == "Warehouse Staff"])
}

model Station {
  id                 String              @id @default(cuid())
  name               String              @unique // e.g., "Cutting", "Sewing", "Wrapping"
  barcode            String?             @unique // For scanning the station itself
  description        String?

  roles              RoleStation[]
  itemProcessingLogs ItemProcessingLog[]
  barcodeScanners    BarcodeScanner[]

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  // Access Control Policies - PERMISSION-BASED (Warehouse setup)
  @@allow('create', auth() != null && auth().roles?[role.permissions?[permission.action == "create" && permission.subject == "Station"]])
  @@allow('read', auth() != null && auth().roles?[role.permissions?[permission.action == "read" && permission.subject == "Station"]])
  @@allow('update', auth() != null && auth().roles?[role.permissions?[permission.action == "update" && permission.subject == "Station"]])
  @@allow('delete', auth() != null && auth().roles?[role.permissions?[permission.action == "delete" && permission.subject == "Station"]])
  
  // ROLE-BASED fallback: Super Admin always has access
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}

model BarcodeScanner {
  id           String   @id @default(cuid())
  prefix       String   @unique // e.g., "S3A"
  stationId    String?  // FK to Station - nullable for office scanners
  userId       String   // FK to User
  model        String?  // Scanner model
  serialNumber String?  // Scanner serial number
  isActive     Boolean  @default(true)
  
  station      Station? @relation(fields: [stationId], references: [id])
  user         User     @relation(fields: [userId], references: [id])
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Access Control Policies - PERMISSION-BASED
  @@allow('create', auth() != null && auth().roles?[role.permissions?[permission.action == "create" && permission.subject == "BarcodeScanner"]])
  @@allow('read', auth() != null && auth().roles?[role.permissions?[permission.action == "read" && permission.subject == "BarcodeScanner"]])
  @@allow('update', auth() != null && auth().roles?[role.permissions?[permission.action == "update" && permission.subject == "BarcodeScanner"]])
  @@allow('delete', auth() != null && auth().roles?[role.permissions?[permission.action == "delete" && permission.subject == "BarcodeScanner"]])
  
  // ROLE-BASED fallback: Super Admin always has access
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}

model RoleStation {
  roleId     String
  stationId  String
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  station    Station  @relation(fields: [stationId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@id([roleId, stationId])
  
  // Access Control Policies - ADMIN-ONLY (Association management)
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
}

model Order {
  id                   String            @id @default(cuid())
  quickbooksOrderId    String?           @unique
  customerId           String
  salesOrderNumber     String?
  purchaseOrderNumber  String?
  poNumber             String?
  
  // Link to the source Estimate
  estimateId           String?           @unique
  
  // New fields from QBO Invoice
  transactionDate      DateTime?
  dueDate              DateTime?
  shipDate             DateTime?
  trackingNumber       String?
  totalAmount          Decimal?          @db.Decimal(10, 2)
  balance              Decimal?          @db.Decimal(10, 2)
  totalTax             Decimal?          @db.Decimal(10, 2)
  emailStatus          String?           // e.g., 'EmailSent', 'NotSet'
  customerMemo         String?           @db.Text

  // Existing contact and address fields
  contactEmail         String
  contactPhoneNumber   String?
  billingAddressLine1  String?
  billingAddressLine2  String?
  billingCity          String?
  billingState         String?
  billingZipCode       String?
  billingCountry       String?
  shippingAddressLine1 String?
  shippingAddressLine2 String?
  shippingCity         String?
  shippingState        String?
  shippingZipCode      String?
  shippingCountry      String?
  orderStatus          OrderSystemStatus @default(PENDING)
  priority             OrderPriority     @default(MEDIUM)
  barcode              String?           @unique
  approvedAt           DateTime?
  readyToShipAt        DateTime?
  shippedAt            DateTime?
  archivedAt           DateTime?
  notes                String?

  customer             Customer          @relation(fields: [customerId], references: [id])
  items                OrderItem[]
  estimate             Estimate?         @relation(fields: [estimateId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  statusLogs           OrderStatusLog[]
  emailNotifications   EmailNotification[]

  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt

  // Database indexes for performance optimization
  @@index([customerId, poNumber])
  @@index([poNumber])
  @@index([customerId, orderStatus])
  @@index([orderStatus, createdAt])

  // Access Control Policies - PERMISSION-BASED (Core warehouse operations)
  // Create orders: Customer service, admins
  @@allow('create', auth() != null && auth().roles?[role.permissions?[permission.action == "create" && permission.subject == "Order"]])
  // Read orders: Most roles need to view orders
  @@allow('read', auth() != null && auth().roles?[role.permissions?[permission.action == "read" && permission.subject == "Order"]])
  // Update orders: Approval workflow, status changes
  @@allow('update', auth() != null && auth().roles?[role.permissions?[permission.action == "update" && permission.subject == "Order"]])
  // Delete orders: Admin-only for corrections
  @@allow('delete', auth() != null && auth().roles?[role.permissions?[permission.action == "delete" && permission.subject == "Order"]])
  
  // ROLE-BASED fallback: Super Admin always has access
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}

model OrderItem {
  id                    String                    @id @default(cuid())
  orderId               String
  order                 Order                     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  itemId                String
  item                  Item                      @relation(fields: [itemId], references: [id])
  quickbooksOrderLineId String?
  quantity              Int
  pricePerItem          Decimal                   @db.Decimal(10, 2)
  lineDescription       String?                   @db.Text // Invoice line description from QBO
  itemStatus            OrderItemProcessingStatus @default(NOT_STARTED_PRODUCTION)
  notes                 String?
  productId             String?
  product               Product?                  @relation(fields: [productId], references: [id])
  isProduct             Boolean                   @default(false) // Whether this item goes to production
  productType           String?                   // SPA_COVER or COVER_FOR_COVER
  
  // Product Attributes (parsed from description)
  size                  String?
  shape                 String?
  radiusSize            String?
  skirtLength           String?
  skirtType             String?                   // CONN or SLIT
  tieDownsQty           String?
  tieDownPlacement      String?                   // HANDLE_SIDE, CORNER_SIDE, FOLD_SIDE
  distance              String?                   @default("0")
  
  // Upgrades
  foamUpgrade           String?                   @default("No")
  doublePlasticWrapUpgrade String?                @default("No")
  webbingUpgrade        String?                   @default("No")
  metalForLifterUpgrade String?                   @default("No")
  steamStopperUpgrade   String?                   @default("No")
  fabricUpgrade         String?                   @default("No")
  
  // Special attributes
  extraHandleQty        String?                   @default("0")
  extraLongSkirt        String?
  packaging             Boolean                    @default(false) // Whether packaging is required
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt

  itemProcessingLogs    ItemProcessingLog[]
  itemStatusLogs        ItemStatusLog[]
  productAttributes     ProductAttribute?
  printQueueItem        PrintQueue?

  @@unique([orderId, quickbooksOrderLineId])
  // Database indexes for performance optimization
  @@index([orderId, itemStatus])
  @@index([itemStatus, createdAt])
  @@index([isProduct, itemStatus])
  
  @@allow('create', auth() != null)
  @@allow('read', auth() != null)
  @@allow('update', auth() != null)
  @@allow('delete', auth() != null)
}

model ItemProcessingLog {
  id                String    @id @default(cuid())
  orderItemId       String
  orderItem         OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  stationId         String
  station           Station   @relation(fields: [stationId], references: [id])
  userId            String
  user              User      @relation(fields: [userId], references: [id])
  startTime         DateTime
  endTime           DateTime? // NULL means currently in progress
  durationInSeconds Int?      // Calculated when endTime is set
  notes             String?   @db.Text

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Access Control Policies - PERMISSION-BASED (Critical for warehouse tracking)
  @@allow('create', auth() != null && auth().roles?[role.permissions?[permission.action == "create" && permission.subject == "ItemProcessingLog"]])
  @@allow('read', auth() != null && auth().roles?[role.permissions?[permission.action == "read" && permission.subject == "ItemProcessingLog"]])
  @@allow('update', auth() != null && auth().roles?[role.permissions?[permission.action == "update" && permission.subject == "ItemProcessingLog"]])
  @@allow('delete', auth() != null && auth().roles?[role.permissions?[permission.action == "delete" && permission.subject == "ItemProcessingLog"]])
  
  // ROLE-BASED fallback: Super Admin always has access
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}

model ProductAttribute {
  id                        String   @id @default(cuid())
  orderItemId               String   @unique
  orderItem                 OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  
  // Product type
  productType               ProductType @default(SPA_COVER)
  
  // Core attributes
  color                     String?
  size                      String?
  shape                     String?
  radiusSize                String?
  length                    String?
  width                     String?
  skirtLength               String?
  skirtType                 SkirtType?
  tieDownsQty               String?
  tieDownPlacement          TieDownPlacement?
  distance                  String? @default("0")
  tieDownLength             String?
  poNumber                  String?
  notes                     String?                   @db.Text
  
  // Upgrades (Yes/No with defaults)
  foamUpgrade               String? // e.g., "2#", "5-2.5", "6-4", "4-5-4", "54""
  doublePlasticWrapUpgrade  String? @default("No")
  webbingUpgrade            String? @default("No")
  metalForLifterUpgrade     String? @default("No")
  steamStopperUpgrade       String? @default("No")
  fabricUpgrade             String? @default("No")
  
  // Special attributes
  extraHandleQty            String? @default("0")
  extraLongSkirt            String? // Calculated or explicit
  packaging                 Boolean                    @default(false) // Whether packaging is required
  verified                    Boolean                    @default(false) // Whether product attributes have been verified by admin
  
  // Metadata
  isParsedFromDescription     Boolean @default(false)
  parsingErrors             String[] // Array of parsing issues
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  // Database indexes for PO validation performance
  @@index([poNumber])
  @@index([orderItemId, poNumber])
  
  @@allow('create', auth() != null)
  @@allow('read', auth() != null)
  @@allow('update', auth() != null)
  @@allow('delete', auth() != null)
}

model PrintQueue {
  id          String   @id @default(cuid())
  orderItemId String   @unique
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  isPrinted   Boolean  @default(false)
  addedAt     DateTime @default(now())
  printedAt   DateTime?
  addedBy     String?  // User ID who added to queue
  printedBy   String?  // User ID who marked as printed
  
  @@index([isPrinted, addedAt])
  @@index([addedAt])
  @@index([addedBy])
  @@index([printedAt])
  @@map("print_queue")

  // Access Control Policies - ROLE-BASED (Office employees, admins, super admins)
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
  @@allow('create,read,update', auth() != null && auth().roles?[role.name == "Office Employee"])
  @@allow('read', auth() != null && auth().roles?[role.name in ["Manager", "Warehouse Staff"]])
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull) // SetNull if user is deleted
  action     String   // e.g., "USER_LOGIN", "UPDATE_ORDER_STATUS"
  entityName String?  // e.g., "Order", "User"
  entityId   String?  // PK of the affected entity
  oldValue   Json?    // Stores previous state for updates
  newValue   Json?    // Stores new state for updates/creates
  ipAddress  String?
  timestamp  DateTime @default(now())

  @@index([entityName, entityId])
  @@index([userId])
  @@index([action])

  // Access Control Policies - SECURITY SENSITIVE (Admin-only)
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
  @@allow('read', auth() != null && auth().roles?[role.name == "Admin"]) // Admins can view audit logs
}

// Comprehensive Order Status Tracking
model OrderStatusLog {
  id           String             @id @default(cuid())
  orderId      String
  order        Order              @relation(fields: [orderId], references: [id], onDelete: Cascade)
  userId       String?          // NULL for system changes
  user         User?              @relation(fields: [userId], references: [id], onDelete: SetNull)
  fromStatus   OrderSystemStatus?
  toStatus     OrderSystemStatus
  changeReason String?          // e.g., "Admin approval", "System automation", "Customer request"
  triggeredBy  String?          // "manual", "system", "automation"
  timestamp    DateTime           @default(now())
  notes        String?            @db.Text

  @@index([orderId])
  @@index([userId])
  @@index([toStatus])
  @@index([timestamp])

  // Access Control Policies - PERMISSION-BASED
  @@allow('create', auth() != null && auth().roles?[role.permissions?[permission.action == "create" && permission.subject == "OrderStatusLog"]])
  @@allow('read', auth() != null && auth().roles?[role.permissions?[permission.action == "read" && permission.subject == "OrderStatusLog"]])
  @@allow('update', auth() != null && auth().roles?[role.permissions?[permission.action == "update" && permission.subject == "OrderStatusLog"]])
  @@allow('delete', auth() != null && auth().roles?[role.permissions?[permission.action == "delete" && permission.subject == "OrderStatusLog"]])
  
  // ROLE-BASED fallback: Super Admin always has access
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}

// Comprehensive Item Status Tracking
model ItemStatusLog {
  id           String                     @id @default(cuid())
  orderItemId  String
  orderItem    OrderItem                  @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  userId       String?                   // NULL for system changes
  user         User?                      @relation(fields: [userId], references: [id], onDelete: SetNull)
  fromStatus   OrderItemProcessingStatus?
  toStatus     OrderItemProcessingStatus
  changeReason String?                   // e.g., "Production started", "Station completed", "System automation"
  triggeredBy  String?                   // "manual", "system", "automation"
  timestamp    DateTime                   @default(now())
  notes        String?                    @db.Text

  @@index([orderItemId])
  @@index([userId])
  @@index([toStatus])
  @@index([timestamp])

  // Access Control Policies - PERMISSION-BASED
  @@allow('create', auth() != null && auth().roles?[role.permissions?[permission.action == "create" && permission.subject == "ItemStatusLog"]])
  @@allow('read', auth() != null && auth().roles?[role.permissions?[permission.action == "read" && permission.subject == "ItemStatusLog"]])
  @@allow('update', auth() != null && auth().roles?[role.permissions?[permission.action == "update" && permission.subject == "ItemStatusLog"]])
  @@allow('delete', auth() != null && auth().roles?[role.permissions?[permission.action == "delete" && permission.subject == "ItemStatusLog"]])
  
  // ROLE-BASED fallback: Super Admin always has access
  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}
// Better Auth Models
model Session {
  id            String   @id @default(cuid()) // Assuming cuid for consistency, though BA might use something else
  expiresAt     DateTime
  token         String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  ipAddress     String?
  userAgent     String?
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersontedBy String?

  @@map("session")
}

model Account {
  id                    String    @id @default(cuid()) // Assuming cuid for consistency
  accountId             String    // Provider specific account ID
  providerId            String    // e.g., "github", "google"
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text // Access tokens can be long
  refreshToken          String?   @db.Text // Refresh tokens can be long
  idToken               String?   @db.Text // ID tokens can be long
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?   // Potentially for provider-specific app passwords?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([providerId, accountId]) // Ensures unique account per provider for a user
  @@map("account")


  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}

model Verification {
  id         String   @id @default(cuid()) // Assuming cuid for consistency
  identifier String    // e.g., email address or user ID
  value      String   @unique // Verification token should be unique
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

model QuickbooksToken {
  id                     String   @id @default(cuid())
  realmId                String
  accessToken            String   @db.Text
  refreshToken           String   @db.Text
  tokenType              String
  expiresIn              Int
  xRefreshTokenExpiresIn Int
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  user                   User     @relation(fields: [userId], references: [id])
  userId                 String   @unique

  // Allow read access for webhook operations (no auth required)
  // Allow write operations only for token owner
  @@allow('read', true) // Webhooks need to read tokens
  @@allow('create,update,delete', auth() != null && userId == auth().id)
}

model QuickBooksIntegration {
  id                       String    @id @default(cuid())
  companyId                String    @unique  // QuickBooks company ID (realmId)
  accessToken              String    @db.Text
  refreshToken             String    @db.Text
  accessTokenExpiresAt     DateTime
  refreshTokenExpiresAt    DateTime
  isActive                 Boolean   @default(true)
  connectedAt              DateTime  @default(now())
  disconnectedAt           DateTime?
  lastRefreshedAt          DateTime?
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  // Access control policies - Admin-only for security
  @@allow('all', auth() != null && auth().roles?[role.name in ["Super Admin", "Admin"]])
}

model Estimate {
  id                   String         @id @default(cuid())
  quickbooksEstimateId String         @unique
  customerId           String
  estimateNumber       String?
  transactionDate      DateTime?
  expirationDate       DateTime?
  totalAmount          Decimal        @db.Decimal(10, 2)

  customer             Customer       @relation(fields: [customerId], references: [id])
  items                EstimateItem[]
  linkedOrder          Order?

  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt

  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}

model EmailNotification {
  id            String   @id @default(cuid())
  orderId       String
  emailType     String   // 'order_approved', 'production_started', etc.
  recipientEmail String
  subject       String
  sentAt        DateTime?
  failedAt      DateTime?
  retryCount    Int      @default(0)
  errorMessage  String?
  
  order         Order    @relation(fields: [orderId], references: [id])
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
  @@allow('read', auth() != null && auth().roles?[role.name == "Admin"])
}

model EstimateItem {
  id                       String   @id @default(cuid())
  estimateId               String
  itemId                   String
  quickbooksEstimateLineId String?  @unique
  lineDescription          String?  @db.Text
  quantity                 Int
  pricePerItem             Decimal  @db.Decimal(10, 2)

  estimate                 Estimate @relation(fields: [estimateId], references: [id], onDelete: Cascade)
  item                     Item     @relation(fields: [itemId], references: [id])

  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  @@allow('all', auth() != null && auth().roles?[role.name == "Super Admin"])
}
